### 1.列表和元组的区别.
  首先，有一点是相同的：列表与元组都是容器，是一系列的对象。二者都可以包含任意类型的元素甚至可以是一个序列，还可以包含元素的顺序（不像集合和字典）。
  列表和元组的“技术差异”是，列表是可变的，而元组是不可变的。这是在 Python 语言中二者唯一的差别。尽管有好几种表现方式，但这是列表和元组唯一的“技术差异”。比如：列表有一个 append() 的方法来添加更多的元素，而元组却没有这个方法，元组并不需要一个 append() 方法，因为元组不能修改。
  “文化差异“是指二者在实际使用中的差异：在你有一些不确定长度的相同类型队列的时候使用列表；在你提前知道元素数量的情况下使用元组，因为元素的位置很重要。

### 2.a = [1, 2, 3, 4]，b = a，b[0] = 100，print(a) 的结果是？
[100, 2, 3, 4]
“深拷贝”。要想修改b而不影响a，赋值的时候，用 b=a[:]。

### 3.list 是怎样实现的.
http://blog.csdn.net/yangyiwxl/article/details/70306089?locationNum=3&fps=1

### 4.list有哪几种添加元素的方法，能否从表头插入元素？
  1. 加单个,  append
  2. 加个list, expend
  3. 最简单的, 两个list可以用"+" (加号)
  4. 指定位置插入，insert

### 5.如何提高Python的运行效率.
  1. 关键代码使用外部功能包——这个窍门要你牺牲应用的可移植性以换取只有通过对底层主机的直接编程才能获得运行效率。以下是一些你可以选择用来提升效率的功能包：Cython、Pylnlne、PyPy、Pyrex； 
  2. 在排序时使用键——尽可能多地使用键和内置的sort()方法； 
  3. 尝试多种编码方法——每次创建应用时都使用同一种编码方法几乎无一例外会导致应用的运行效率不尽人意； 
  4. 交叉编译你的应用——为了运行你的应用，你借助一个应用将你所编的人类可读的代码转换成机器可读的代码，但是，如果你用的是一个资源很有限的系统，这种方法或许不太可行； 
  5. 针对循环的优化——尽量避免在循环中访问变量的属性； 
  6. 使用较新的Python版本——保证自己的代码在新版本里还能运行。 

### 6.如何获取list中最后一个元素.
list[-1]

### 7.Python 垃圾回收机制
  Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题。通过“分代回收”（generation collection）以空间换取时间来进一步提高垃圾回收的效率。
  引用计数原理：当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1；当对象的引用计数减少为0时，就意味着对象已经没有被任何人使用了，可以将其所占用的内存释放了。虽然引用计数必须在每次分配和释放内存的时候加入管理引用计数的动作，然而与其他主流的垃圾收集技术相比，引用计数有一个最大的有点，即“实时性”，任何内存，一旦没有指向它的引用，就会立即被回收。而其他的垃圾收集计数必须在某种特殊条件下（比如内存分配失败）才能进行无效内存的回收。
  标记-清除原理：“标记-清除”采用了更好的做法，我们并不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护。
  分代回收原理：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。

### 8.Python 深、浅复制区别和应用场景
  Python中的元素有可变值元素与不可变值元素。不可变值元素如数值型、字符串、元组等，它们在复制的过程中会直接根据值创建一个新的对象。而对于可变值元素，如列表、字典等，复制的时候往往不能够生成一个全新的对象。这就是深复制与浅复制。
  copy模块用于对象的拷贝操作。两个主要的方法： copy.copy 与 copy.deepcopy ，分别表示浅复制与深复制。 
  浅复制只复制对象本身，没有复制该对象所引用的对象。